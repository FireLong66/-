# 数据结构

二叉树的遍历时间复杂度。

深度优先、广度优先。

哈希表

优先队列（最小堆）

# 路径规划概念

## **单源最短路径（Single-Source Shortest Path, SSSP）**

- **定义**：计算图中**从一个起点（源点）到所有其他节点**的最短路径。

- **特点**：

  - 输入：指定起点 `s`。
  - 输出：`s` 到所有 `v ∈ V` 的最短距离 `dist[s→v]` 及路径。

- **典型算法**：

  | 算法             | 时间复杂度   | 适用条件           |
  | :--------------- | :----------- | :----------------- |
  | **Dijkstra**     | O((V+E)logV) | 边权**非负**       |
  | **Bellman-Ford** | O(VE)        | 允许负权，检测负环 |
  | **A***           | O((V+E)logV) | 启发式优化         |

- **应用场景**：

  - 导航系统中“从我的位置到所有目的地的最短路线”。
  - 网络路由中“从本路由器到其他节点的最优路径”。

## **全源最短路径（All-Pairs Shortest Path, APSP）**

- **定义**：计算图中**任意两个节点之间的最短路径**。

- **特点**：

  - 输入：无需指定起点，覆盖所有节点对。
  - 输出：`dist[u→v]` 矩阵（`u, v ∈ V`）。

- **典型算法**：

  | 算法               | 时间复杂度     | 适用条件           |
  | :----------------- | :------------- | :----------------- |
  | **Floyd-Warshall** | O(V³)          | 允许负权，检测负环 |
  | **Johnson**        | O(V²logV + VE) | 稀疏图非负权优化   |

- **应用场景**：

  - 交通规划中“所有城市之间的最短距离表”。
  - 社交网络中“任意两人之间的最短关系链”。

| **维度**       | 单源最短路径           | 全源最短路径             |
| :------------- | :--------------------- | :----------------------- |
| **计算目标**   | 固定起点到所有其他节点 | 所有节点对之间的最短路径 |
| **输出形式**   | 一维数组 `dist[s→v]`   | 二维矩阵 `dist[u→v]`     |
| **空间复杂度** | O(V)                   | O(V²)                    |
| **适用算法**   | Dijkstra, Bellman-Ford | Floyd-Warshall, Johnson  |



# **无权图最短路径算法**

无信息搜索算法仅依赖图的拓扑结构（顶点和边的连接关系），不利用额外信息（如边的权重、目标位置的先验知识），适用于简单或未知环境。

## **广度优先搜索（Breadth-First Search, BFS）**

- **原理**：从起点开始，优先探索所有**相邻顶点**，再逐层探索更远的顶点（“先到先得”）。
- 特点：
  - 保证找到**最短路径（边数最少）**（适用于边权重相同的图）。
  - 时间复杂度 *O*(*V*+*E*)（*V* 为顶点数，*E* 为边数），空间复杂度较高（需存储所有待探索顶点）。
- **适用场景**：网格图、无权图的最短路径（如迷宫求解）。

## **深度优先搜索（Depth-First Search, DFS）**

- **原理**：从起点出发，沿一条路径深入探索，直到无法前进再回溯，选择其他路径（“一条路走到黑”）。
- 特点：
  - 不保证找到最短路径，可能陷入无限深路径。
  - 时间复杂度 *O*(*V*+*E*)，空间复杂度较低（递归或栈存储路径）。
- **适用场景**：拓扑排序、连通性检测，不适合路径规划（因无法保证最优）。

## **深度受限搜索（Depth-Limited Search, DLS）与迭代加深搜索（Iterative Deepening Search, IDS）**

- **DLS**：为 DFS 设置最大深度限制，避免无限递归，但可能因深度设置不合理错过目标。
- **IDS**：多次执行 DLS，每次增加深度限制（从 0 开始），结合 BFS 的完备性和 DFS 的空间效率，适用于深度未知的图。

# 基于图搜索的带权图路径规划算法

## 问题

### Dijkstra和A*都具有概率完备性吗？

**概率完备性**主要用于描述随机化算法（如概率规划算法）在解决问题时的性能。如果一个算法在时间趋于无穷时，找到解的概率趋近于1（假设解存在），则该算法是概率完备的。

确定性完备：对于给定的问题，如果存在解，那么相关算法或系统在遵循既定规则和有限步骤内，必然能够找到该解，并且每次执行的结果都是确定的，不会出现随机或不确定的情况。

- **Dijkstra和A***是确定性算法，具有**确定性完备性**，而非概率完备性。



### Dijkstra算法需要维护每个节点到终点的代价？

Dijkstra算法**不需要也不维护节点到终点的代价**，它仅动态更新从起点到其他节点的最短路径代价。

### weighted-A*只能找到次优解，但是快？

Weighted A* 是对标准 A* 的改进，通过引入一个权重系数ϵ来调整启发式函数h(n)的权重

*f*(*n*)=*g*(*n*)+*ϵ*⋅*h*(*n*)

**速度-最优性权衡**：*ϵ* 越大，速度越快，但解的质量越低；

速度快，但不一定能找到最优解，通常是次优解，但也可能找到最优解。

### 不同地图表示影响Dijstra算法的复杂度吗？

地图的表示方式（**数据结构**）会直接影响Dijkstra算法的时间复杂度和空间复杂度。

1. **图的存储方式**（邻接矩阵 vs. 邻接表）
2. **优先级队列的实现**（普通数组、二叉堆、斐波那契堆等）
3. **图的稀疏性**（边数 E和顶点数 V 的关系）

Dijkstra的核心操作是**松弛（Relaxation）**，即更新节点的最短距离，而不同的图存储方式会影响其效率：

| 存储方式     | 空间复杂度 | 查找邻居的时间 | 适用场景          |
| :----------- | :--------- | :------------- | :---------------- |
| **邻接矩阵** | O(V^2)     | O(V)           | 稠密图（E = V^2） |
| **邻接表**   | O(V+E)     | O(1) 平均      | 稀疏图（E<< V^2） |

- **邻接矩阵**：
  - 每次查找某个节点的所有邻居需要遍历整个行（O(V)）。
  - 适合**边数接近完全图**的情况（如网格地图）。
- **邻接表**：
  - 直接存储每个节点的邻居，查找更快（平均 O(1)）。
  - 适合**边数远少于 V^2** 的情况（如道路网络、社交网络）。





### A*和Dijkstra的时间复杂度一样吗？启发项是算法常数优化？

#### **1. 时间复杂度对比**

| 算法         | 时间复杂度（最坏情况） | 适用场景                 |
| :----------- | :--------------------- | :----------------------- |
| **Dijkstra** | O((V + E) \log V)      | 无权图或有权图的最短路径 |
| **A***       | O((V + E) \log V)      | 带启发式信息的图搜索     |

**结论**：
在最坏情况下，A* 和 Dijkstra 的**渐进时间复杂度相同**（均为优先队列实现的 O((V + E) \log V)），但实际运行效率可能差异巨大，原因在于**启发式函数 h(n) 的优化作用**。

**启发式项的影响**：

1. **减少搜索范围**：
   - 如果 h(n) **准确**（接近真实代价），A* 会优先探索更接近目标的节点，大幅减少扩展的节点数（远低于 Dijkstra）。
   - 极端情况下，若 h(n)恒等于 0，A* 退化为 Dijkstra。
2. **不改变渐进复杂度，但优化常数因子**：
   - 虽然最坏情况下时间复杂度仍为 O((V + E) ×log V)，但实际运行时间可能快几个数量级（例如仅需检查 10% 的节点）。





## 图论基础知识

### **邻接矩阵**

定义：用 V × V 的二维矩阵表示图，如果节点 i 和 j之间有边，为1或权重。无边则为0。

特点：

- 空间复杂度：O(V^2)

- 查询邻居：直接访问 `matrix[i][j]`（O(1)）。

- 适用场景：稠密图（边数 E ≈ V^2），如网格地图。

  例子：节点：A, B, C, D；边：A-B, A-C, B-C, C-D

  |      | A    | B    | C    | D    |
  | :--- | :--- | :--- | :--- | ---- |
  | A    | 0    | 1    | 1    | 0    |
  | B    | 1    | 0    | 1    | 0    |
  | C    | 1    | 1    | 0    | 1    |
  | D    | 0    | 0    | 1    | 0    |

### 邻接表

定义：用数组或哈希表存储每个节点的邻居列表：

每个节点对应一个链表或动态数组，存储其直接连接的邻居（及权重）。

特点：

- 空间复杂度：O(V + E)（仅存储实际存在的边）。

- 查询邻居：遍历链表（平均 O(1) 或 O(k)，k 为邻居数）。

- 适用场景：稀疏图（边数 E <<V^2），如社交网络、道路网络。

```
{
    'A': ['B', 'C'],
    'B': ['A', 'C'],
    'C': ['A', 'B', 'D'],
    'D': ['C']
}
```

| **特性**           | 邻接矩阵           | 邻接表             |
| :----------------- | :----------------- | :----------------- |
| **空间**           | O(V^2)（浪费空间） | O(V+E)（节省空间） |
| **检查两节点连接** | O(1)               | O(k)（需遍历链表） |
| **遍历所有邻居**   | O(V)（全扫描）     | O(k)（直接访问）   |
| **适用场景**       | 稠密图             | 稀疏图             |

---

## Dijkstra算法

### 概述

迪杰斯特:用于**求解带权有向图或无向图中单源最短路径**的经典算法。适用于**边权值非负**的图，能够高效地计算从起点到其他所有顶点的最短路径，不能有效处理带有负权边的图。

核心思想：贪心 + 优先队列

### 算法步骤

1. **初始化**

   - `dist[s] = 0`，其余 `dist[v] = ∞`（`v ∈ V`）
   - 优先队列（最小堆）`Q` 初始化为 `{ (s, 0) }`
   - 可选：记录前驱节点的数组 `prev[v]`（用于回溯路径）

2. **主循环**（直到 `Q` 为空）：

   - **取出当前距离最小的节点** `u`：

     ```
     u = Q.extract_min()  # O(log V)
     ```

   - **遍历 `u` 的所有邻接节点 `v`**（邻接表访问）：

     - **计算新距离**：`alt = dist[u] + w(u, v)`

     - **如果 `alt < dist[v]`，则更新**：

       ```
       dist[v] = alt          # 更新最短距离
       prev[v] = u            # 记录前驱节点（可选）
       Q.insert_or_update(v, alt)  # 插入或更新堆中的 v，O(log V)
       ```

3. **终止**

   - 当 `Q` 为空时，`dist[]` 存储了 `s` 到所有节点的最短距离。
   - 通过 `prev[]` 可回溯具体路径（如 `s → ... → prev[v] → v`）。

### 算法实现（数据结构与复杂度）

1. **数据结构**：

   - 图的表示：邻接表（高效存储稀疏图）或邻接矩阵（适合稠密图）。
   - 距离表：数组或哈希表，存储起点到各顶点的当前最短距离。
   - 顶点选择：使用**优先队列（最小堆）** 快速获取`U`中距离最近的顶点（时间复杂度更优）。

2. **时间复杂度分析**：

   - 若使用**邻接矩阵**+ 线性查找选点：`O(V²)`（`V`为顶点数），适合顶点少的图。

     - 选点操作：每次从剩余V-1, V-2, ..., 1个顶点中线性扫描找最小值，总次数为O(V²)（V + (V-1) + ... + 1 = V(V+1)/2 ≈ O(V²)）。
     - 松弛操作：每个顶点被选中后，需遍历其所有邻接顶点（邻接矩阵中需检查所有V个顶点），总次数为O(V²)（V次迭代，每次O(V)）。

   - 若使用**邻接表**+ 优先队列：`O((V+E)logV)`（`E`为边数），适合稀疏图（`E`较小）。

     - **选点操作**：提取最小距离节点（堆顶），每次从堆中提取最小值（`O(1)`），但需维护堆结构，总耗时`O(V log V)`（共`V`次提取，每次堆调整`O(log V)`）。

     - **松弛操作**（处理邻接边）：每条边会触发一次距离更新，若更新后需将顶点插入堆（可能重复插入），总边数为`E`，每次堆操作`O(log V)`，因此耗时`O(E log V)`。

       

3. **空间复杂度分析**

   - **基于邻接矩阵的实现**
     图的存储：邻接矩阵需要V×V的二维数组存储边权，空间复杂度为O(V²)。
     辅助数据结构
     - 距离数组（存储起点到各顶点的距离）：O(V)；
     - 标记数组（记录顶点是否已确定最短路径）：O(V)。
     - 总空间复杂度：O(V²)（主要由邻接矩阵主导）。

   - **基于邻接表的实现**

     - **图的存储**：邻接表中每个顶点存储其邻接边，总空间为`O(V + E)`（`V`个顶点的表头 + `E`条边的信息）。

     - 辅助数据结构：
       - 距离数组：`O(V)`；
       - 标记数组：`O(V)`；
       - 优先队列（堆）：最多存储`O(E)`个顶点（可能重复插入），因此空间`O(E)`。

     - **总空间复杂度**：`O(V + E)`（主要由邻接表和堆的开销主导）。

| 实现方式            | 时间复杂度        | 空间复杂度 | 适用场景           |
| ------------------- | ----------------- | ---------- | ------------------ |
| 邻接矩阵 + 线性查找 | `O(V²)`           | `O(V²)`    | 稠密图             |
| 邻接表 + 优先队列   | `O((V + E)log V)` | `O(V + E)` | 稀疏图（实际常用） |

​	

### 为什么每次从堆中取出距离最小的顶点u，耗时O(log n)

每次从堆（最小堆）中取出距离最小的顶点`u`的操作（称为 “Extract-Min”）耗时`O(log n)`，这是由**最小堆的结构特性**和**维护堆序的操作成本**决定的。

最小堆是一种**完全二叉树**（除最后一层外，每层节点均填满，最后一层节点靠左排列），且满足**堆序性质**：**任意节点的值小于等于其左右子节点的值**。

Extract-Min 操作的执行过程

1. **取出根节点**：直接获取根节点的值（即当前堆中最小的元素，对应算法中距离最小的顶点`u`），此步骤耗时`O(1)`。
2. **填补根节点的空缺**：将堆的**最后一个节点**（最底层最右侧的节点）移动到根节点位置，以维持完全二叉树的结构，此步骤耗时`O(1)`。
3. **堆的 “下沉” 调整（Heapify-Down）**由于新根节点可能破坏堆序性质（大于其子女），需要将其与左右子节点中较小的一个交换位置，并重复此过程，直到堆序性质恢复。



### 算法局限性

- **仅适用于非负权值**：若图中存在负权边，算法可能失效（无法正确更新距离）。
- **无法处理负权回路**：即使边权非负，若存在负权回路（总权值为负的环），最短路径可能不存在（可无限绕环缩短距离）。



---

## A*启发式

### 核心思想

是一种**启发式**搜索算法，通过结合**代价函数**和**启发函数**，在保证找到最短路径（最优解）的前提下，高效地从起点搜索到终点。

A * 算法通过启发函数`h(n)`引导搜索方向，比盲目搜索（如 Dijkstra）更高效，且在`h(n)`满足可采纳性时能保证最短路径。其性能高度依赖`h(n)`的设计（如网格地图中常用**曼哈顿距离**或**欧氏距离**作为`h(n)`）。

核心公式：

```
f(n) = g(n) + h(n)
```

- `g(n)`：从起点到当前节点`n`的实际代价（已走路径长度）。
- `h(n)`：从当前节点`n`到终点的**估计代价**（启发函数，需满足**可采纳性**：`h(n) ≤ 实际代价`，以保证最优解）。
- `f(n)`：节点`n`的总估计代价，算法通过`f(n)`值选择下一个最可能接近终点的节点扩展，减少无效搜索。

### 算法步骤

1. **初始化**
   - 建立两个集合：
     - **开放列表（Open List）**：待检查的节点（初始仅包含起点，`g=0`，`h`由启发函数计算）。
     - **关闭列表（Closed List）**：已检查的节点（初始为空）。
2. **循环搜索**
   - 从开放列表中选取`f(n)`最小的节点`n`，作为当前处理节点。
   - 若`n`是终点，**回溯路径**（通过每个节点记录的 “父节点” 反推从起点到终点的路径），算法结束。
   - 否则，将n移至关闭列表，遍历其所有相邻节点m：
     - 若`m`在关闭列表，跳过。
     - 若`m`不在开放列表：计算`g(m) = g(n) + 距离(n,m)`，`h(m)`，`f(m) = g(m) + h(m)`，将`m`加入开放列表，并记录父节点为`n`。
     - 若`m`已在开放列表：计算新的`g(m) = g(n) + 距离(n,m)`，若新`g(m)`更小（即从`n`到`m`的路径更优），则更新`m`的`g(m)`、`f(m)`和父节点。
3. **若开放列表为空**：表示终点不可达，算法结束。

### 算法实现

##### 1.关键数据结构

- **开放列表**：需高效获取`f(n)`最小的节点，常用**优先队列（堆）** 实现（支持`O(1)`获取最小值，`O(logN)`插入 / 更新）。
- **关闭列表**：需快速判断节点是否已处理，常用**哈希表**或**布尔数组**实现（`O(1)`查询）。
- **节点存储**：每个节点需记录坐标、`g(n)`、`h(n)`、`f(n)`及父节点指针（用于回溯路径）。

##### 2. 时间复杂度

- 最坏情况时间复杂度O(b^d)
  - b 是平均分支因子（每个节点的平均子节点数）
  - d 是目标节点的最短路径深度（步数）
    这是指数级复杂度，与Dijkstra算法相同（当启发函数h(n)=0时，A*退化为Dijkstra）。

##### 3. 空间复杂度

主要取决于开放列表和关闭列表的存储规模，最坏情况下为`O(V)`（`V`为总节点数），因需存储所有可能访问的节点信息。



## weighted-A*







## 双向 A 算法（Bidirectional A）







## **Bellman-Ford 算法**









# 基于采样的路径规划算法

## 问题

### RRT*，KD树，区域树，L1范数和L2范数

RRT* 是 RRT（快速探索随机树）的改进版本，用于**高维空间路径规划**（如机器人运动规划）。它在 RRT 的基础上增加了**渐进最优性**，即随着时间推移，路径会不断优化至接近理论最优解。核心优势是**能在概率完备的基础上找到次优路径**，并逐步收敛到最优解。

- 算法通过在配置空间（如机器人运动的二维 / 三维空间）中随机采样点，不断扩展一棵 “随机树”：从起点出发，每次随机生成一个目标点，在树中找到距离该点最近的节点，然后从最近节点向随机点方向扩展一小段距离，形成新节点并加入树中。

- 与 RRT 的区别：RRT * 在新增节点时，会额外搜索新节点周围的 “邻居节点”（而非仅用最近节点），通过比较从不同邻居节点到达新节点的路径代价，选择**代价最小的路径**连接新节点，实现路径的 “优化”。

  ---

KD 树（K-Dimensional Tree）

是一种高维空间中的数据索引结构，用于高效地进行最近邻搜索和范围查询，本质是对 k 维空间数据的二叉树划分。

**树结构构建**：

- 递归划分 k 维空间：每次选择一个维度（通常按数据分布最分散的维度），在该维度上找一个中位数作为分割点，将空间分为左右两部分（如二维空间中，先按 x 轴划分，再按 y 轴划分，交替进行）。
- 每个节点存储：分割维度、分割值、对应的数据点，以及左右子树（分别对应分割后两部分的子空间）。

**高效查询**：

- **最近邻搜索**：从根节点出发，根据查询点在分割维度上的值，优先搜索更可能包含最近点的子树；同时记录当前最优解，回溯时判断另一子树是否可能存在更近的点，若可能则继续搜索，否则剪枝。

- 相比暴力搜索（O (n)），KD 树的查询时间复杂度约为 O (log n)（高维空间中性能会下降，称为 “维度灾难”）。

  ---

区域树（Range Tree）

区域树是一种用于**多维空间范围查询**的索引结构，能高效回答 “在某个 k 维矩形区域内有哪些数据点” 等问题。

核心概念与原理：

1. **分层结构**：
   - 区域树是一种**多层二叉搜索树**：第一层按第一维度对所有数据点排序并构建二叉搜索树；每个节点的子树对应一个子范围，且每个节点会额外存储该子范围内数据点在第二维度上的子区域树（递归到 k 维）。
   - 例如，二维区域树的根节点对应 x 轴全范围，其左子树对应 x < a 的范围，该左子树节点会存储所有 x < a 的数据点在 y 轴上的区域树。
2. **范围查询过程**：
   - 对 k 维查询区域，从第一维度开始，在区域树中找到所有符合该维度范围的节点，再递归到这些节点的子树中查询下一维度，最终收集所有满足所有维度范围的数据点。
   - 时间复杂度：构建树为 O (n (log n)^(k-1))，查询为 O ((log n)^k + m)，其中 m 是查询结果的数量。

应用场景：

地理信息系统（GIS）中的空间范围查询、多维数据的统计分析等。

---

**L1 范数（L1 Norm）**

L1 范数是**向量空间中衡量向量 “长度” 的一种度量方式**，也称为 “曼哈顿距离”（在二维空间中）或 “出租车范数”。

核心概念与计算公式：

对于一个 n 维向量**x**=(*x*1,*x*2,...,*x**n*)，其 L1 范数定义为：∥**x**∥1=∣*x*1∣+∣*x*2∣+...+∣*x**n*∣
即向量各元素的绝对值之和。

特点与应用：

- **几何意义**：在二维空间中，L1 范数等于从原点到点 (x,y) 沿坐标轴 “直角转弯” 的路径长度（如从 (0,0) 到 (3,4) 的 L1 距离为 3+4=7）。

- **稀疏性**：L1 范数优化（如 Lasso 回归）会使解向量中更多元素为 0，常用于特征选择（剔除不重要的特征）。

- 对异常值的鲁棒性优于 L2 范数。

  ---

**L2 范数（L2 Norm）**

L2 范数也是衡量向量长度的度量方式，又称 “欧几里得范数”，对应常见的 “直线距离”。

核心概念与计算公式：

对于 n 维向量**x**=(*x*1,*x*2,...,*x**n*)，其 L2 范数定义为：∥**x**∥2=根号下(x1^2+*x*2^2+...+xn^2)
即向量各元素平方和的平方根（平方 L2 范数为各元素平方和，优化中更常用，因避免开方运算）。

特点与应用：

- **几何意义**：在二维空间中，L2 范数是原点到点 (x,y) 的直线距离（如 (0,0) 到 (3,4) 的 L2 距离为 5）。
- **平滑性**：L2 范数优化（如 Ridge 回归）会使解向量的元素值更均匀（避免过大值），常用于抑制过拟合（正则化）。
- 对异常值较敏感（平方项会放大异常值的影响）。





### RRT：概率完备、高维度、狭窄通道

- **概率完备**：意味着只要从起点到终点存在一条可行的路径，并且规划的时间足够长，那么 RRT 算法就能以概率 1 找到这样一条路径。RRT 算法通过随机采样来构建搜索树，随着时间的推移，树的结构会不断扩展，覆盖的搜索空间也会逐渐增大，直至找到目标点或覆盖到足够大的搜索区域，从而大概率找到可行路径。
- **高维度**：RRT 算法适用于高维度空间。在高维空间中，传统的网格搜索算法计算复杂度会呈指数级增长，启发式搜索则容易陷入局部最优解。而 RRT 算法通过随机采样的方式，有效地避免了这些问题，其计算复杂度对搜索空间的维度不敏感，能够快速地探索搜索空间，在机器人运动规划、机械臂控制等高维空间相关领域具有广泛的应用前景。
- **狭窄通道**：是指空间受限、障碍物分布复杂的环境区域。在狭窄通道环境中，RRT 算法存在一定局限性。由于狭窄通道面积小，随机采样点很难准确地落在其中，导致随机树在扩展过程中难以进入通道，降低了找到通过狭窄通道路径的成功率。而且 RRT 算法在扩展树时没有针对性地对狭窄通道进行处理，可能会在通道外进行大量不必要的搜索，浪费计算资源，生成的初始路径也可能存在较多转折点，路径质量不高。









## **RRT（快速随机探索树）**



## PRM（概率路线图)





# 基于启发式优化算法的路径规划算法



# 轨迹优化算法